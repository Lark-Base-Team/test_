import{i as q,r as me,h as l,j as V,U as $,I as se,L as pe,H as oe,k as z,l as ye,n as ee,s as te,t as le,v as K,E as U,S as be,w as C,x as he}from"./index-Bu-wPQDb.js";var _=(e=>(e.Update="update",e.Delete="delete",e.Add="add",e.Link="link",e.Async="async",e))(_||{});const ie=200,ce=200,ue=200,Re=200,we=200;async function Ie(e,a){const r=await e.getName();return async s=>{try{const t=await e.addRecords(s.map(n=>n.data));s.forEach((n,d)=>{t[d]&&(n.result=t[d],n.status=z.Success)}),a(l.onAddRecords,{stage:"addRecords",data:{success:s,message:{text:"importInfo.addRecordsMessage",params:{table:r}}}})}catch(t){U({title:"addRecordsFailure",message:String(t),error:t}),s.forEach(n=>{n.status=z.Error}),a(l.onAddRecords,{stage:"addRecords",data:{error:s}})}}}async function Te(e,a){const r=await e.getName();return async s=>{try{const t=await e.setRecords(s.map(n=>n.data).flat());s.forEach((n,d)=>{t[d]&&(n.result=t[d],n.status=z.Success)}),a(l.onUpdateRecords,{stage:"updateRecords",data:{success:s,message:{text:"importInfo.updateRecordsMessage",params:{table:r}}}})}catch(t){U({title:"updateRecordsFailure",message:String(t),error:t}),s.forEach(n=>{n.status=z.Error}),a(l.onUpdateRecords,{stage:"updateRecords",data:{error:s}})}}}async function Fe(e,a){const r=await e.getName();return async s=>{try{const t=await e.deleteRecords(s.map(n=>n.data).flat());t&&s.forEach(n=>{n.result=t,n.status=z.Success}),a(l.onDeleteRecords,{stage:"deleteRecords",data:{success:s,message:{text:"importInfo.deleteRecordsMessage",params:{table:r}}}})}catch(t){U({title:"deleteRecordsFailure",message:String(t),error:t}),s.forEach(n=>{n.status=z.Error}),a(l.onDeleteRecords,{stage:"deleteRecords",data:{error:s}})}}}async function Se(e,a,r=ie,s=500,t){await C(r,s,e,await Ie(a,t))}async function xe(e,a,r=ue,s=500,t){return await C(r,s,e,await Te(a,t))}async function Ee(e,a,r=ce,s=500,t){return await C(r,s,e,await Fe(a,t))}async function Ve(e,a,r,s,t){return e===a?null:r===q.merge_direct||a===null?await V.getCell(s,t,e):await V.getCell(s,t,a)}async function ne(e,a,r=!1,s,t){try{const n=await he.base.getTable(e),[d,u,f]=await Promise.all([n.getName(),n.getFieldList(),n.getFieldMetaList()]);s(l.onReadFieldMap,{stage:"readFieldMap",data:{message:{text:"importInfo.getTable",params:{name:d,id:e}}}});const y=f.filter(i=>i.isPrimary)[0].id;return{id:e,table:n,name:d,primaryField:y,indexId:t!=null&&t.length?t:[y],root:r,fields:u.reduce((i,g)=>(i[g.id]=g,i),{}),fieldMaps:a}}catch(n){throw U({title:"getTableFailure",message:String(n),error:n,notice:!0,noticeParams:{text:"message.getTableFailure",params:{id:e}}}),n}}async function de(e,a,r=1e4,s=0){const t=[];return await C(r,s,e,async n=>{await Promise.allSettled(n.map(async d=>{const u=await a(d);Array.isArray(u)?t.push(...u):t.push(u)}))}),t}async function ge(e,a,r,s,t,n,d,u){if(!V.asyncTypes.includes(a.field.type))return null;const f=await V.normalization(e,a);if(!f)return null;const y=[f],S={table:{name:s[a.table].name,id:a.table},action:_.Async,data:y,result:void 0,status:z.Wait,target:u,asyncField:a,value:e,field:r};n.push(S)}async function fe(e,a,r,s,t,n,d,u){var j;if(!((j=a.children)!=null&&j.length))return null;const{linkConfig:f}=a,{allowAdd:y,primaryKey:S}=f??{};if(!S||y===void 0)return null;const i=await V.normalization(e,a),g=s[a.field.property.tableId],v=t[g.id],D=[];d(l.onAnalyzeRecords,{stage:"analyzeRecords",data:{message:{text:"importInfo.getLinkRecord",params:{indexValue:i.join("|"),fieldName:a.field.name,fieldId:r.id,table:g.name}}}});const J=i.map(O=>{const B=v.filter(P=>P.indexValue[0]===O);return B.length===0?(D.push(O),null):B.map(P=>P.recordId)}).flat().filter(O=>O!==null);if((!D.length||!y)&&J.length){const O=await V.getCell(r,a,J.join(a.config.separator??","));return O||null}}async function re(e,a,r,s,t,n,d){var g;if(!a.excel_field||!a.writable)return null;const u=e[a.excel_field]??null;if(!u)return null;const f=r[a.table].fields[a.field.id],y=le.includes(a.field.type),{linkConfig:S}=a,{primaryKey:i}=S??{};if(y&&a.hasChildren&&((g=a.children)!=null&&g.length)&&i)return await fe(u,a,f,r,s,t,n);if(V.asyncTypes.includes(a.field.type)&&await ge(u,a,f,r,s,t,n,d),!y){const v=await V.getCell(f,a,u);if(v)return v}return null}async function Ae(e,a){try{let r=!1;if(!a){const t=await e.addField({type:oe.ModifiedTime});a=await e.getField(t),r=!0}const s=await a.getFieldValueList();return r&&e.deleteField(a),s.reduce((t,n)=>(n.record_id&&(t[n.record_id]=n.value),t),{})}catch(r){return U({title:"getModifiedTimeFailure",message:String(r),error:r,notice:!0,noticeParams:{text:"message.getModifiedTimeFailure",params:{id:e.id}}}),{}}}async function Me(e,a,r){let s={};const t=e[0].table;s[t]=await ne(t,e,e[0].root,r,a);for(const n of e)if(n.excel_field&&n.hasChildren&&n.linkConfig&&!Object.keys(s).includes(n.field.property.tableId)){const d=n.field.property.tableId;s[d]=await ne(d,n.children??[],!1,r,n.linkConfig.primaryKey?[n.linkConfig.primaryKey]:void 0)}return s}async function H(e,a=3){try{return await e()}catch(r){if(a<=0)throw r;return await H(e,a-1)}}async function Oe(e,a=we){let r=!0,s,t=[];for(;r;){const{hasMore:n,recordIds:d,pageToken:u}=await H(async()=>await e.getRecordIdListByPage({pageSize:a,pageToken:s}));r=n,s=u,t.push(...d)}return t}async function De(e){let a=!0,r,s=[];for(;a;){const{hasMore:t,records:n,pageToken:d}=await H(async()=>await e.getRecordsByPage({pageToken:r,stringValue:!0}));a=t,r=d,s=s.concat(n)}return s}async function _e(e,a,r){const s=await Oe(e);return await Promise.all(a.map(async n=>(r(l.onReadFieldMap,{stage:"readFieldMap",data:{message:{text:"importInfo.getIndexField",params:{name:n.field.name,id:n.field.id}}}}),{fieldMap:n}))).then(async n=>{const d=await De(e),u=new Map;return d.forEach(f=>{u.set(f.recordId,f.fields)}),{res:n,recordsValueMap:u}}).then(async n=>{const{res:d,recordsValueMap:u}=n;return Promise.all(s.map(async f=>{var S;const y=[];for(const i of d){const g=((S=u.get(f))==null?void 0:S[i.fieldMap.key])??"";r(l.onReadFieldMap,{stage:"readFieldMap",data:{message:{text:"importInfo.analyzeIndexFieldValue",params:{fieldName:i.fieldMap.field.name,fieldId:i.fieldMap.field.id,recordId:f}}}});const v=await V.normalization(g,i.fieldMap,{separator:",",format:["yyyy/MM/dd","yyyy/MM/dd HH:mm","yyyy-MM-dd HH:mm","yyyy-MM-dd","MM-dd","MM/dd/yyyy","dd/MM/yyyy"]});y.push(v)}return{indexValue:y,table:e.id,recordId:f,fieldMaps:a}})).catch(f=>{throw U({title:"getTableIndexFailure",message:String(f),error:f,notice:!0,noticeParams:{text:"message.getTableIndexFailure",params:{id:e.id}}}),f})})}async function ze(e){const a=[];let r;for(;;){const s=await H(async()=>await e.getRecordsByPage({pageSize:Re,pageToken:r}));if(r=s.pageToken,a.push(...s.records),!s.hasMore||!r)break}return a.reduce((s,t)=>(s[t.recordId]=t.fields,s),{})}async function Le(e,a,r,s){for(const t of e){if(!be.includes(t.field.type))continue;const n=t.excel_field;if(!n)continue;s(l.onReadFieldMap,{stage:"readFieldMap",data:{message:{text:"importInfo.checkSelectFieldOptions",params:{fieldName:t.field.name,fieldId:t.field.id}}}});const d=r.map(i=>i[n]).filter(te),u=a[t.field.id],f=(await u.getOptions()).map(i=>i.name),S=ee((await Promise.all(d.map(async i=>await V.normalization(i,t)))).filter(te).flat()).filter(i=>!f.includes(i));if(S.length){s(l.onReadFieldMap,{stage:"readFieldMap",data:{message:{text:"importInfo.setSelectFieldOptions",params:{fieldName:t.field.name,fieldId:t.field.id,newOptionsNum:String(S.length)}}}});try{await u.addOptions(S.map(i=>({name:i})))}catch(i){const g=await u.getName();U({title:"setSelectFieldOptionsFailure",message:`set select field ${g}[${u.id}] options failure`,error:i,notice:!0,noticeParams:{text:"message.setSelectFieldOptionsFailure",params:{id:t.field.id,name:g}}})}}}}async function je(e,a,r,s=null,t=q.append,n={},d=me){var ae;console.log(e),d(l.onStart,{stage:"start"}),V.refresh(),d(l.beforeReadFieldMap,{stage:"readFieldMap",data:{progress:!1}});const{parallel:u={records:1e4,fields:10},interval:f={records:0,fields:0},allowAction:y={add:!0,update:!0,delete:!0},updateOption:S={mode:[$.SAVE_MOST,$.SAVE_LATEST]}}=n;se({title:"importInfo.start",message:`
    Mode: ${t}
    SheetIndex: ${r}
    index: ${s}
    parallel:
      - fields: ${u.fields}
      - records: ${u.records}
    interval:
      - fields: ${f.fields}
      - records: ${f.records}
    allowAction:
      - add: ${y.add}
      - update: ${y.update}
      - delete: ${y.delete}
    updateOption:
      - mode: ${S.mode}
    `});const i=a.sheets[r].tableData.records,g=await Me(e,s??[],d);pe({title:"tables",message:JSON.stringify(g,null,2)});const v=[],D=g[e[0].table].table;let J={};if(t!==q.append){d(l.onReadFieldMap,{stage:"readFieldMap",data:{message:{text:"importInfo.getRecordsModifiedTime"}}});const p=(ae=e.find(h=>h.field.type===oe.ModifiedTime))==null?void 0:ae.field.id,x=p?await D.getField(p):void 0;J=await Ae(D,x)}await Le(e,g[e[0].table].fields,i,d);const j={};await Promise.all(Object.values(g).map(async p=>{const x=p.indexId,h=await _e(p.table,x.map(w=>p.fieldMaps.find(m=>m.field.id===w)),d);j[p.id]=h.map(w=>({...w,modifiedTime:J[w.recordId]??0}))})),s&&s.length&&v.push(...j[D.id]),d(l.onReadFieldMapEnd,{stage:"readFieldMap"});const O=[];if(d(l.beforeAnalyzeRecords,{stage:"analyzeRecords",data:{progress:!0,number:i.length,success:0,error:0}}),t===q.append||!s){const p=await de(i,async x=>{const h=[],w={table:{id:e[0].table,name:g[e[0].table].name},action:_.Add,data:[],result:void 0,status:z.Wait},m=[];for(const I of e){const T=await re(x,I,g,j,h,d,w);T&&m.push(T)}return d(l.onAnalyzeRecords,{stage:"analyzeRecords",data:{number:i.length,success:1,error:0}}),m.length&&(w.data.push(...m),h.push(w)),h},u.records,f.records);O.push(...p)}else{const p=s.map(m=>{const I=e.find(T=>T.field.id===m);return I||null});se({title:"excelIndexField",message:JSON.stringify(p,null,2)}),d(l.onAnalyzeRecords,{stage:"analyzeRecords",data:{message:{text:"importInfo.getTableRecords",params:{table:D.id}}}});const x=await ze(D),h=[],w=await de(i,async m=>{var k;const I=[],T=await Promise.all(p.map(async o=>await V.normalization(m[o.excel_field]??"",o))),N=v.filter(o=>ye(o.indexValue,T));d(l.onAnalyzeRecords,{stage:"analyzeRecords",data:{message:{text:"importInfo.findSameRecord",params:{indexValue:T.join("|"),number:String(N.length)}}}});const M=[];let A=null;if(N.length>=1){for(const o of N){d(l.onAnalyzeRecords,{stage:"analyzeRecords",data:{message:{text:"importInfo.getSameRecord",params:{indexValue:T.join("|"),recordId:o.recordId}}}});const F=x[o.recordId],R={...o,tableValues:Object.keys(F).reduce((b,c)=>(F[c]!==null&&(b[c]=F[c]),b),{})};M.push(R)}if(M.length>1){const{mode:o}=S;if([$.SAVE_LATEST,$.SAVE_OLDEST].includes(o[0])){const F=ee(M.map(c=>c.modifiedTime)),R=o[0]===$.SAVE_LATEST?Math.max(...F):Math.min(...F),b=M.filter(c=>c.modifiedTime===R);if(b.length===1){const c=b[0];A={id:c.recordId,table:c.table,tableValues:c.tableValues}}else{b.sort((X,G)=>Object.values(X.tableValues).length-Object.values(G.tableValues).length);const c=o[1]===$.SAVE_MOST?b[b.length-1]:b[0];A={id:c.recordId,table:c.table,tableValues:c.tableValues}}}else{const F=ee(M.map(c=>Object.values(c.tableValues).length)),R=o[0]===$.SAVE_MOST?Math.max(...F):Math.min(...F),b=M.filter(c=>Object.values(c.tableValues).length===R);if(b.length===1){const c=b[0];A={id:c.recordId,table:c.table,tableValues:c.tableValues}}else{b.sort((X,G)=>X.modifiedTime-G.modifiedTime);const c=o[1]===$.SAVE_LATEST?b[b.length-1]:b[0];A={id:c.recordId,table:c.table,tableValues:c.tableValues}}}if(te(A)){const F=M.map(R=>R.recordId).filter(R=>R!==A.id).filter(R=>!h.includes(R));h.push(...F),I.push(...F.map(R=>({table:{id:D.id,name:g[D.id].name},action:_.Delete,data:[R],result:void 0,status:z.Wait})))}}else{const o=M[0];A={id:o.recordId,table:o.table,tableValues:o.tableValues}}}const E={table:{id:D.id,name:g[D.id].name},action:_.Add,data:[],result:void 0,status:z.Wait},L=[];for(const o of e){if(!o.excel_field||!o.writable)continue;const F=m[o.excel_field]??"",R=g[o.table].fields[o.field.id];if(d(l.onAnalyzeRecords,{stage:"analyzeRecords",data:{message:{text:"importInfo.compareRecordField",params:{fieldName:o.field.name,fieldId:R.id,indexValue:T.join("|")}}}}),y.add&&!N.length){const W=await re(m,o,g,j,I,d,E);L.push(W)}if(!y.update||!A)continue;const b=le.includes(o.field.type),{linkConfig:c}=o,{primaryKey:X}=c??{},G=A.tableValues[o.field.id]??null;if(b&&o.hasChildren&&((k=o.children)!=null&&k.length)&&X&&(t===q.merge_direct||G===null)){const W=await fe(F,o,R,g,j,O,d);L.push(W)}if(V.asyncTypes.includes(o.field.type)&&await ge(F,o,R,g,j,O,d,E),!b){const W=await Ve(F,G,t,R,o);W&&L.push(W)}}if(d(l.onAnalyzeRecords,{stage:"analyzeRecords",data:{number:i.length,success:1,error:0}}),M.length){E.action=_.Update;const o={};for(const R of L.filter(b=>b!==null)){const[b,c]=await Promise.all([R.getFieldId(),R.getValue()]);o[b]=c}const F={recordId:A.id,fields:o};return E.data.push(F),I.push(E),I}return E.data.push(...L.filter(o=>o!==null)),I.push(E),I},u.records,f.records);O.push(...w)}d(l.onAnalyzeRecordsEnd,{stage:"analyzeRecords"});const B=K(O,"action"),P=B[_.Async];if(P&&P.length){const p=K(P,"asyncField.field.type"),x=Object.keys(p),h=x.reduce((m,I)=>(m[I]=p[I].map(T=>T.data).flat(),m),{});d(l.beforeAsyncData,{stage:"asyncData",data:{progress:!0,number:P.length,success:[],error:[]}});for(const m of x){const I=p[m];await V.asyncMethod({data:h[m],onProgress:T=>{const{message:N="",loaded:M,total:A}=T;d(l.onAsyncData,{stage:"asyncData",data:{message:{text:N+`
${M}/${A}`}}})},onError:T=>{U({title:"asyncDataFailure",message:String(T),error:T})}},I[0].asyncField)}const w=K(P,"table.id");for(const m of Object.keys(w)){const I=g[m],T=w[m],N=K(T,"asyncField.field.id");for(const M of Object.keys(N)){const A=I.fields[M];for(const E of N[M]){d(l.onAsyncData,{stage:"asyncData",data:{message:{text:"importInfo.createCell",params:{fieldId:A.id,tableId:m}}}});const L=await V.getCell(A,E.asyncField,E.value);if(!(!L||!E.target)){if(E.target.action===_.Add)E.target.data.push(L);else if(E.target.action===_.Update){const[k,o]=await Promise.all([L.getFieldId(),L.getValue()]);E.target.data[0].fields[k]=o}E.status=z.Success}}}}d(l.onAsyncDataEnd,{stage:"asyncData"})}const Y=B[_.Delete];if(Y&&y.delete&&Y.length){d(l.beforeDeleteRecords,{stage:"deleteRecords",data:{progress:!0,number:Y.length,success:[],error:[]}});const p=K(Y,"table.id"),x=Object.keys(p);for(const h of x){const w=g[h],m=p[h];await Ee(m,w.table,ce,0,d)}d(l.onDeleteRecordsEnd,{stage:"deleteRecords"})}const Q=B[_.Add];if(Q&&(t===q.append||y.add)&&Q&&Q.length){d(l.beforeAddRecords,{stage:"addRecords",data:{progress:!0,number:Q.length,success:[],error:[]}});const p=K(Q,"table.id"),x=Object.keys(p);for(const h of x){const w=g[h],m=p[h];await Se(m,w.table,ie,0,d)}d(l.onAddRecordsEnd,{stage:"addRecords"})}const Z=B[_.Update];if(Z&&y.update&&Z.length){d(l.beforeUpdateRecords,{stage:"updateRecords",data:{progress:!0,number:Z.length,success:[],error:[]}});const p=K(Z,"table.id"),x=Object.keys(p);for(const h of x){const w=g[h],m=p[h];await xe(m,w.table,ue,0,d)}d(l.onUpdateRecordsEnd,{stage:"updateRecords"})}V.reset(),d(l.onEnd,{stage:"end"})}export{je as importExcel};
